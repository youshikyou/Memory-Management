5.1 Copy Semantics
    Default copying
    Resource management is one of the primary responsibilities of a C++ programmer. 
    Among resources such as multi-threaded locks, files, network and database connections this also includes memory. 
    The common denominator in all of these examples is that access to the resource is often managed through a handle 
    such as a pointer. Also, after the resource has been used and is no longer, it must be released again 
    so that it available for re-use by someone else.

    In C++, a common way of safely accessing resources is by wrapping a manager class around the handle, 
    which is initialized when the resource is acquired (in the class constructor) and released when it is deleted 
    (in the class destructor). This concept is often referred to as Resource Acquisition is Initialization (RAII),
    which we will discuss in greater depth in the next concept. One problem 
    with this approach though is that copying the manager object will also copy the handle of the resource. 
    This allows two objects access to the same resource - and this can mean trouble.

    Consider the example5.1.1.cpp of managing access to a block of heap memory.

    The class MyClass has a private member, which is a pointer to a heap-allocated integer. 
    Allocation is performed in the constructor, deallocation is done in the destructor. 
    This means that the memory block of size sizeof(int) is allocated when the objects myClass1 and myClass2 are created 
    on the stack and deallocated when their scope is left, which happens at the end of the main. 
    The difference between myClass1 and myClass2 is that the latter is instantiated using the copy constructor, 
    which duplicates the members in myClass1 - including the pointer to the heap memory where _myInt resides.

    The output of the program looks like the following:
        Own address on the stack is 0x7ffeefbff670
        Managing memory block on the heap at 0x100300060
        Own address on the stack is 0x7ffeefbff658
        Managing memory block on the heap at 0x100300060
        copy_constructor_1(87582,0x1000a95c0) malloc: *** error for object 0x100300060: pointer being freed was not allocated
    
    From the output we can see that the stack address is different for myClass1 and myClass2 
    - as was expected. The address of the managed memory block on the heap however is identical. 
    This means that when the first object goes out of scope, it releases the memory resource by calling free in its destructor. 
    The second object does the same - which causes the program to crash as the pointer 
    is now referencing an invalid area of memory, which has already been freed.

    The default behavior of both copy constructor and assignment operator is to perform a shallow copy 
    as with the example above. The 5.1.1 figure illustrates the concept.

    Fortunately, in C++, the copying process can be controlled by defining a tailored copy constructor 
    as well as a copy assignment operator. The copying process must be closely linked to the respective resource release 
    mechanism and is often referred to as copy-ownership policy. Tailoring the copy constructor 
    according to your memory management policy is an important choice you often need to make when designing a class. 
    In the following, we will closely examine several well-known copy-ownership policies.



    No copying policy
    The simplest policy of all is to forbid copying and assigning class instances all together. 
    This can be achieved by declaring, but not defining a private copy constructor and assignment operator 
    (see NoCopyClass1 below) or alternatively by making both public and assigning the delete operator 
    (see NoCopyClass2 below). 
    The second choice is more explicit and makes it clearer to the programmer that copying has been actively forbidden. 
    Let us have a look at a code example5.1.2nocopy.cpp
    On compiling, we get the following error messages:
        error: calling a private constructor of class 'NoCopyClass1'
        NoCopyClass1 copy1(original1);
        NoCopyClass1 copy1b = original1; 

        error: call to deleted constructor of 'NoCopyClass2'
        NoCopyClass2 copy2(original2);
        NoCopyClass2 copy2b = original2;

    Both cases effectively prevent the original object from being copied or assigned. 
    In the C++11 standard library, there are some classes for multi-threaded synchronization which use the no copying policy.



    Exclusive ownership policy
    This policy states that whenever a resource management object is copied, 
    the resource handle is transferred from the source pointer to the destination pointer. 
    In the process, the source pointer is set to nullptr to make ownership exclusive. 
    At any time, the resource handle belongs only to a single object, which is responsible for its deletion
    when it is no longer needed.

    The example5.1.2exclusiveownership.cpp illustrates the basic idea of exclusive ownership.

    The class MyClass overwrites both the copy constructor as well as the assignment operator. 
    Inside, the handle to the resource _myInt is first copied from the source object 
    and then set to null so that only a single valid handle exists. 
    After copying, the new object is responsible for properly deleting the memory resource on the heap. 
    The output of the program looks like the following:
        resource allocated
        resource freed
    As can be seen, only a single resource is allocated and freed. So by passing handles and invalidating them, 
    we can implement a basic version of an exclusive ownership policy. 
    However, this example is not the way exclusive ownership is handled in the standard template library. 
    One problem in this implementation is that for a short time there are effectively two valid handles to the same resource 
    - after the handle has been copied and before it is set to nullptr. In concurrent programs, this would cause a data race 
    for the resource. A much better alternative to handle exclusive ownership in C++ would be to use move semantics.



    Deep copying policy
    With this policy, copying and assigning class instances to each other is possible without the danger of resource conflicts.
    The idea is to allocate proprietary memory in the destination object and then to copy the content to which the source 
    object handle is pointing into the newly allocated block of memory. 
    This way, the content is preserved during copy or assignment. However, this approach increases the memory demands 
    and the uniqueness of the data is lost: After the deep copy has been made, two versions of the same resource exist 
    in memory.

    Let us look at the example5.1.3deepcopy.cpp.

    The deep-copy version of MyClass looks similar to the exclusive ownership policy: 
    Both the assignment operator and the copy constructor have been overloaded with the source object passed by reference. 
    But instead of copying the source handle (and then deleting it), a proprietary block of memory is allocated on the heap
    and the content of the source is copied into it.

    The output of the program looks like the following:
    resource allocated at address 0x100300060
    resource allocated at address 0x100300070 with _myInt = 42
    resource allocated at address 0x100300080 with _myInt = 42
    resource freed at address 0x100300080
    resource freed at address 0x100300070
    resource freed at address 0x100300060

    As can be seen, all copies have the same value of 42 while the address of the handle differs 
    between source, dest1 and dest2.



    Shared ownership policy
    The last ownership policy we will be discussing in this course implements a shared ownership behavior.
    The idea is to perform a copy or assignment similar to the default behavior, 
    i.e. copying the handle instead of the content (as with a shallow copy) while at the same time 
    keeping track of the number of instances that also point to the same resource. 
    Each time an instance goes out of scope, the counter is decremented. 
    Once the last object is about to be deleted, it can safely deallocate the memory resource. 
    We will see later in this course that this is the central idea of unique_ptr, 
    which is a representative of the group of smart pointers.

    The example5.1.4sharedowenership.cpp.
    Note that class MyClass now has a static member _cnt, 
    which is incremented every time a new instance of MyClass is created and decrement once an instance is deleted. 
    On deletion of the last instance, i.e. when _cnt==0, the block of memory to which the handle points is deallocated.

    The output of the program is the following:
        resource allocated at address 0x100300060
        2 instances with handles to address 0x100300060 with _myInt = 42
        3 instances with handles to address 0x100300060 with _myInt = 42
        4 instances with handles to address 0x100300060 with _myInt = 42
        instance at address 0x7ffeefbff6f8 goes out of scope with _cnt = 3
        instance at address 0x7ffeefbff700 goes out of scope with _cnt = 2
        instance at address 0x7ffeefbff718 goes out of scope with _cnt = 1
        resource freed at address 0x100300060

    As can be seen, the memory is released only once as soon as the reference counter reaches zero.



    The Rule of Three
    In the previous examples we have taken a first look at several copying policies:

        Default copying
        No copying
        Exclusive ownership
        Deep copying
        Shared ownership
    In the first example we have seen that the default implementation of the copy constructor does not consider the "special"
    needs of a class which allocates and deallocates a shared resource on the heap. 
    The problem with implicitly using the default copy constructor or assignment operator 
    is that programmers are not forced to consider the implications for the memory management policy of their program. 
    In the case of the first example, this leads to a segmentation fault and thus a program crash.

    In order to properly manage memory allocation, deallocation and copying behavior, we have seen 
    that there is an intricate relationship between destructor, copy constructor and copy assignment operator. 
    To this end, the Rule of Three states that if a class needs to have an overloaded copy constructor, 
    copy assignment operator, ~or~ destructor, then it must also implement the other two as well to ensure 
    that memory is managed consistently. As we have seen, the copy constructor and copy assignment operator 
    (which are often almost identical) control how the resource gets copied between objects while the destructor manages 
    the resource deletion.

    You may have noted that in the previous code example, the class SharedCopy does not implement the assignment operator. 
    This is a violation of the Rule of Three and thus, if we were to use something like destination3 
    = source instead of SharedCopy destination3(source), the counter variable would not be properly decremented.

5.2 Lvalues and Rvalues
    What are lvalues and rvalues?
    A good grasp of lvalues and rvalues in C++ is essential for understanding the more advanced concepts of rvalue references
    and motion semantics.

    Let us start by stating that every expression in C++ has a type and belongs to a value category. 
    When objects are created, copied or moved during the evaluation of an expression, 
    the compiler uses these value expressions to decide which method to call or which operator to use.

    Prior to C++11, there were only two value categories, now there are as many as five of them,figure 5.2.1.

    To keep it short, we do not want to go into all categories, but limit ourselves to lvalues and prvalues:

    Lvalues have an address that can be accessed. They are expressions whose evaluation by the compiler determines the identity
    of objects or functions.

    Prvalues do not have an address that is accessible directly. 
    They are temporary expressions used to initialize objects or compute the value of the operand of an operator.

    For the sake of simplicity and for compliance with many tutorials, videos and books about the topic, 
    let us refer to prvalues as rvalues from here on.

    The two characters l and r are originally derived from the perspective of the assignment operator =, 
    which always expects a rvalue on the right, and which it assigns to a lvalue on the left. In this case, 
    the l stands for left and r for right:

        int i = 42;  // lvalue = rvalue;

    With many other operators, however, this right-left view is not entirely correct. 
    In more general terms, an lvalue is an entity that points to a specific memory location. 
    An rvalue is usually a short-lived object, which is only needed in a narrow local scope. 
    To simplify things a little, one could think of lvalues as named containers for rvalues.

    In the example above, the value 42 is an rvalue. It does not have a specific memory address which we know about. 
    The rvalue is assigned to a variable i with a specific memory location known to us, 
    which is what makes it an lvalue in this example.

    Using the address operator & we can generate an lvalue from an rvalue and assign it to another lvalue:

        int *j = &i;

    In this small example, the expression &i generates the address of i as an rvalue and assigns it to j, 
    which is an lvalue now holding the memory location of i.

    The code on the example5.2.1lrexample.cpp illustrates several examples of lvalues and rvalues。



    Lvalue references
    An lvalue reference can be considered as an alternative name for an object. 
    It is a reference that binds to an lvalue and is declared using an optional list of specifiers 
    (which we will not further discuss here) followed by the reference declarator &. The example5.2.2lvaluerefereces.ccp 
    declares an integer i and a reference j which can be used as an alias for the existing object.

        The output of the program is
        i = 3, j = 3

    We can see that the lvalue reference j can be used just as i can. A change to either i or j will affect.

    One of the primary use-cases for lvalue references is the pass-by-reference semantics in function calls as in the example5.2.2lvaluerefereces2.ccp

    The function myFunction has an lvalue reference as a parameter, which establishes an alias to the integer i which is passed to it in main.



    Rvalue references
    You already know that an rvalue is a temporary expression which is - among other use-cases, a means of initializing objects. 
    In the call int i = 42, 42 is the rvalue.

    Let us consider an example5.2.3rvaluereferences.cpp.

    As before, the function myFunction takes an lvalue reference as its argument. In main, the call myFunction(j) works just fine 
    while myFunction(42) as well as myFunction(j+k) produces the compiler error.


    While the number 42 is obviously an rvalue, with j+k things might not be so obvious, as j and k are variables and thus lvalues. 
    To compute the result of the addition, the compiler has to create a temporary object to place.

    Since C++11, there is a new type available called rvalue reference, which can be identified from the double ampersand && after a type name.
    With this operator, it is possible to store and even modify an rvalue, i.e. a temporary object which would otherwise be lost quickly.
    See example5.2.3rvaluereferences2.cpp

    After creating the integers i and j on the stack, the sum of both is added to a third integer k. 
    Let us examine this simple example a little more closely. In the first and second assignment, i and j are created as lvalues, 
    while 1 and 2 are rvalues, whose value is copied into the memory location of i and j. 
    Then, a third lvalue, k, is created. The sum i+j is created as an rvalue, which holds the result of the addition 
    before being copied into the memory location of k. This is quite a lot of copying and holding of temporary values in memory. 
    With an rvalue reference, this can be done more efficiently.

    The expression int &&l creates an rvalue reference, to which the address of the temporary object is assigned, 
    that holds the result of the addition. So instead of first creating the rvalue i+j , then copying it and finally deleting it, 
    we can now hold the temporary object in memory. This is much more efficient than the first approach, 
    even though saving a few bytes of storage in the example might not seem like much at first glance. 
    One of the most important aspects of rvalue references is that they pave the way for move semantics, 
    which is a mighty technique in modern C++ to optimize memory usage and processing speed. 
    Move semantics and rvalue references make it possible to write code that transfers resources such as dynamically allocated memory 
    from one object to another in a very efficient manner and also supports the concept of exclusive ownership, 
    as we will shortly see when discussing smart pointers. 

5.3 Moving Semantics
    Rvalue references and std::move
    C++11 called move semantics.

    The last section on lvalues, rvalues and especially rvalue references is an important prerequisite for understanding the concept of moving
    data structures.

    Let us consider the function on example5.3.1rvalue.cpp which takes an rvalue reference as its parameter.

    The important message of the function argument of myFunction to the programmer is : 
    The object that binds to the rvalue reference &&val is yours, it is not needed anymore within the scope of the caller (which is main). 
    As discussed in the previous section on rvalue references, this is interesting from two perspectives:

        1.Passing values like this improves performance as no temporary copy needs to be made anymore and
        2.ownership changes, since the object the reference binds to has been abandoned by the caller and now binds to a handle 
        which is available only to the receiver. This could not have been achieved with lvalue references as any change to the object 
        that binds to the lvalue reference would also be visible on the caller side.

    There is one more important aspect we need to consider: rvalue references are themselves lvalues. While this might seem confusing at first
    glance, it really is the mechanism that enables move semantics: A reference is always defined in a certain context 
    (such as in the above example the variable val) . Even though the object it refers to (the number 42) may be disposable in the context 
    it has been created (the main function), it is not disposable in the context of the reference . 
    So within the scope of myFunction, val is an lvalue as it gives access to the memory location where the number 42 is stored.

    Note however that in the example5.3.1rvalue.cpp we cannot pass an lvalue to myFunction, 
    because an rvalue reference cannot bind to an lvalue. The code
        int i = 23;
        myFunction(i)
    would result in a compiler error. There is a solution to this problem though: 
    The function std::move converts an lvalue into an rvalue 
    (actually, to be exact, into an xvalue, which we will not discuss here for the sake of clarity), 
    which makes it possible to use the lvalue as an argument for the function:
        int i = 23; 
        myFunction(std::move(i));
    In doing this, we state that in the scope of main we will not use i anymore, which now exists only in the scope of myFunction. 
    Using std::move in this way is one of the components of move semantics, which we will look into shortly. 
    But first let us consider an example of the Rule of Three.

    Let us consider the example to the right of a class which manages a block of dynamic memory and incrementally add new functionality to it. 
    You will add the main function shown above later on in this notebook.

    In this class, a block of heap memory is allocated in the constructor and deallocated in the destructor. As we have discussed before, 
    when either destructor, copy constructor or copy assignment operator are defined, 
    it is good practice to also define the other two (known as the Rule of Three).
    While the compiler would generate default versions of the missing components, 
    these would not properly reflect the memory management strategy of our class, 
    so leaving out the manual implementation is usually not advised.

    So let us start with the copy constructor of MyMovableClass, which could look like the following:
        MyMovableClass(const MyMovableClass &source) // 2 : copy constructor
        {
            _size = source._size;
            _data = new int[_size];
            *_data = *source._data;
            std::cout << "COPYING content of instance " << &source << " to instance " << this << std::endl;
        }
    The copy constructor takes an lvalue reference to the source instance, allocates a block of memory of the same size as in the source 
    and then copies the data into its members (as a deep copy).

    Next, let us take a look at the copy assignment operator:
        MyMovableClass &operator=(const MyMovableClass &source) // 3 : copy assignment operator
    {
        std::cout << "ASSIGNING content of instance " << &source << " to instance " << this << std::endl;
        if (this == &source)
            return *this;
        delete[] _data;
        _data = new int[source._size];
        *_data = *source._data;
        _size = source._size;
        return *this;
    }

    The if-statement at the top of the above implementation protects against self-assignment and is standard boilerplate code 
    for the user-defined assignment operator. The remainder of the code is more or less identical to the copy constructor, 
    apart from returning a reference to the own instance using this.

    You might have noticed that both copy constructor and assignment operator take a const reference to the source object as an argument, 
    by which they promise that they won’ (and can’t) modify the content of source.

    In the main above, the object obj1 is created using the regular constructor of MyMovableClass. 
    Then, both the copy constructor as well as the assignment operator are used with the latter one not creating a new object 
    but instead assigning the content of obj1 to obj2 as defined by our copying policy.

    The output of this textbook implementation of the Rule of Three looks like this:
        CREATING instance of MyMovableClass at 0x7ffeefbff618 allocated with size = 40 bytes

        COPYING content of instance 0x7ffeefbff618 to instance 0x7ffeefbff608

        ASSIGNING content of instance 0x7ffeefbff618 to instance 0x7ffeefbff608

        DELETING instance of MyMovableClass at 0x7ffeefbff608

        DELETING instance of MyMovableClass at 0x7ffeefbff618

    


    Limitations of Our Current Class Design
    Let us now consider one more way to instantiate MyMovableClass object by using createObject() function. 
    Add the following function definition to the rule_of_three.cpp, outside the scope of the class MyMovableClass:
        MyMovableClass createObject(int size)
        {
            MyMovableClass obj(size); // regular constructor
            return obj; // return MyMovableClass object by value
        }
    Note that when a function returns an object by value, the compiler creates a temporary object as an rvalue. 
    Let's call this function inside main to create an obj4 instance, as follows:
    int main()
    {
        // call to copy constructor, (alternate syntax)
        MyMovableClass obj3 = obj1;
        // Here, we are instantiating obj3 in the same statement; hence the copy assignment operator would not be called.
        MyMovableClass obj4 = createObject(10);
        // createObject(10) returns a temporary copy of the object as an rvalue, which is passed to the copy constructor.
        /*
        * You can try executing the statement below as well
        * MyMovableClass obj4(createObject(10));
        */

        return 0;
    }
    In the main above, the returned value of createObject(10) is passed to the copy constructor. 
    The function createObject() returns an instance of MyMovableClass by value. In such a case, 
    the compiler creates a temporary copy of the object as an rvalue, which is passed to the copy constructor.

    A special call to copy constructor
    Try compiling and then running the rule_of_three.cpp to notice that MyMovableClass obj4 = createObject(10); 
    would not print the cout statement of copy constructor on the console. 
    This is because the copy constructor is called on the temporary object.

    In our current class design, while creating obj4, the data is dynamically allocated on the stack, 
    which is then copied from the temporary object to its target destination. This means that two expensive memory operations 
    are performed with the first occurring during the creation of the temporary rvalue and the second during the execution 
    of the copy constructor. The similar two expensive memory operations would be performed with the assignment operator 
    if we execute the following statement inside main:
        MyMovableClass obj4 = createObject(10); // Don't write this statement if you have already written it before
        obj4 = createObject(10); // call to copy assignment operator

    In the above call to copy assignment operator, it would first erase the memory of obj4, 
    then reallocate it during the creation of the temporary object; and then copy the data from the temporary object to obj4.

    From a performance viewpoint, this code involves far too many copies, making it inefficient - especially with large data structures. 
    Prior to C++11, the proper solution in such a case was to simply avoid returning large data structures by value to prevent the expensive 
    and unnecessary copying process. With C++11 however, there is a way we can optimize this and return even large data structures by value. 
    The solution is the move constructor and the Rule of Five.



    The move constructor
    The basic idea to optimize the code from the last example is to "steal" the rvalue generated by the compiler 
    during the return-by-value operation and move the expensive data in the source object to the target object 
    - not by copying it but by redirecting the data handles. Moving data in such a way is always cheaper than making copies, 
    which is why programmers are highly encouraged to make use of this powerful tool.

    The 5.3.1 diagram illustrates the basic principle of moving a resource from a source object to a destination object:
    In order to achieve this, we will be using a construct called move constructor, 
    which is similar to the copy constructor with the key difference being the re-use of existing data without unnecessarily copying it. 
    In addition to the move constructor, there is also a move assignment operator, which we need to look at.

    Just like the copy constructor, the move constructor builds an instance of a class using a source instance. 
    The key difference between the two is that with the move constructor, the source instance will no longer be usable afterwards. 
    Let us take a look at an implementation of the move constructor for our MyMovableClass:
            MyMovableClass(MyMovableClass &&source) // 4 : move constructor
        {
            std::cout << "MOVING (c’tor) instance " << &source << " to instance " << this << std::endl;
            _data = source._data;
            _size = source._size;
            source._data = nullptr;
            source._size = 0;
        }
    
    In this code, the move constructor takes as its input an rvalue reference to a source object of the same class. 
    In doing so, we are able to use the object within the scope of the move constructor. 
    As can be seen, the implementation copies the data handle from source to target 
    and immediately invalidates source after copying is complete. Now, this is responsible for the data 
    and must also release memory on destruction - the ownership has been successfully changed (or moved) 
    without the need to copy the data on the heap.

    The move assignment operator works in a similar way:
            MyMovableClass &operator=(MyMovableClass &&source) // 5 : move assignment operator
        {
            std::cout << "MOVING (assign) instance " << &source << " to instance " << this << std::endl;
            if (this == &source)
                return *this;

            delete[] _data;

            _data = source._data;
            _size = source._size;

            source._data = nullptr;
            source._size = 0;

            return *this;
        }

    As with the move constructor, the data handle is copied from source to target which is coming in as an rvalue reference again. 
    Afterwards, the data members of source are invalidated. 
    The rest of the code is identical with the copy constructor we have already implemented.



    The Rule of Five
    By adding both the move constructor and the move assignment operator to our MyMovableClass, we have adhered to the Rule of Five. 
    This rule is an extension of the Rule of Three which we have already seen and exists since the introduction of the C++11 standard. 
    The Rule of Five is especially important in resource management, where unnecessary copying needs to be avoided due to limited resources 
    and performance reasons. Also, all the STL container classes such as std::vector implement the Rule of Five and use move semantics 
    for increased efficiency.

    The Rule of Five states that if you have to write one of the functions listed below then you should consider implementing all of them with
    a proper resource management policy in place. If you forget to implement one or more, the compiler will usually generate the missing ones
    (without a warning) but the default versions might not be suitable for the purpose you have in mind. The five functions are:

    1.The destructor: Responsible for freeing the resource once the object it belongs to goes out of scope.

    2.The assignment operator: The default assignment operation performs a member-wise shallow copy, 
    which does not copy the content behind the resource handle. If a deep copy is needed, it has be implemented by the programmer.

    3.The copy constructor: As with the assignment operator, the default copy constructor performs a shallow copy of the data members. 
    If something else is needed, the programmer has to implement it accordingly.

    4.The move constructor: Because copying objects can be an expensive operation which involves creating, 
    copying and destroying temporary objects, rvalue references are used to bind to an rvalue. Using this mechanism, 
    the move constructor transfers the ownership of a resource from a (temporary) rvalue object to a permanent lvalue object.

    5.The move assignment operator: With this operator, ownership of a resource can be transferred from one object to another. 
    The internal behavior is very similar to the move constructor.



    When are move semantics used?
    Now that we have seen how move semantics work, let us take a look at situations where they actually apply.

    One of the primary areas of application are cases, where heavy-weight objects need to be passed around in a program. 
    Copying these without move semantics can cause series performance issues. 
    The idea in this scenario is to create the object a single time and then "simply" move it around using rvalue references 
    and move semantics.

    A second area of application are cases where ownership needs to be transferred (such as with unique pointers, as we will soon see). 
    The primary difference to shared references is that with move semantics we are not sharing anything but instead 
    we are ensuring through a smart policy that only a single object at a time has access to and thus owns the resource.

    Let us look at some code examples:
        int main()
    {
        MyMovableClass obj1(100), obj2(200); // constructor

        MyMovableClass obj3(obj1); // copy constructor

        MyMovableClass obj4 = obj1; // copy constructor

        obj4 = obj2; // copy assignment operator

        return 0;
    }

    If you compile and run this code, be sure to use the -std=c++11 flag. The reasons for this will be explained below.

    In the code above, in total, four instances of MyMovableClass are constructed here. 
    While obj1 and obj2 are created using the conventional constructor, 
    obj3 is created using the copy constructor instead according to our implementation. Interestingly, 
    even though the creation of obj4 looks like an assignment, the compiler calls the copy constructor int this case. 
    Finally, the last line calls the copy assignment operator. 
    The output of the above main function looks like the following:
        CREATING instance of MyMovableClass at 0x7ffeefbff718 allocated with size = 400 bytes

        CREATING instance of MyMovableClass at 0x7ffeefbff708 allocated with size = 800 bytes

        COPYING content of instance 0x7ffeefbff718 to instance 0x7ffeefbff6e8

        COPYING content of instance 0x7ffeefbff718 to instance 0x7ffeefbff6d8

        ASSIGNING content of instance 0x7ffeefbff708 to instance 0x7ffeefbff6d8

        DELETING instance of MyMovableClass at 0x7ffeefbff6d8
        DELETING instance of MyMovableClass at 0x7ffeefbff6e8
        DELETING instance of MyMovableClass at 0x7ffeefbff708
        DELETING instance of MyMovableClass at 0x7ffeefbff718

    Note that the compiler has been called with the option -fno-elide-constructors to turn off an optimization techniques called copy elision,
    which would make it harder to understand the various calls and the operations they entail. 
    This technique is guaranteed to be used as of C++17, which is why we are also reverting to the C++11 standard 
    for the remainder of this chapter using -std=c++11. Until now, no move operation has been performed yet as all of the above calls 
    were involving lvalues.

    Now consider the following main function instead:
        int main()
    {
        MyMovableClass obj1(100); // constructor

        obj1 = MyMovableClass(200); // move assignment operator

        MyMovableClass obj2 = MyMovableClass(300); // move constructor 

        return 0;
    }
    In this version, we also have an instance of MyMovableClass, obj1. 
    Then, a second instance of MyMovableClass is created as an rvalue, which is assigned to obj1. 
    Finally, we have a second lvalue obj2, which is created by assigning it an rvalue object. 
    Let us take a look at the output of the program:
        CREATING instance of MyMovableClass at 0x7ffeefbff718 allocated with size = 400 bytes

        CREATING instance of MyMovableClass at 0x7ffeefbff708 allocated with size = 800 bytes

        MOVING (assign) instance 0x7ffeefbff708 to instance 0x7ffeefbff718

        DELETING instance of MyMovableClass at 0x7ffeefbff708

        CREATING instance of MyMovableClass at 0x7ffeefbff6d8 allocated with size = 1200 bytes

        MOVING (c'tor) instance 0x7ffeefbff6d8 to instance 0x7ffeefbff6e8

        DELETING instance of MyMovableClass at 0x7ffeefbff6d8
        DELETING instance of MyMovableClass at 0x7ffeefbff6e8
        DELETING instance of MyMovableClass at 0x7ffeefbff718
    By looking at the stack addresses of the objects, 
    we can see that the temporary object at 0x7ffeefbff708 is moved to 0x7ffeefbff718 using the move assignment operator we wrote earlier, 
    because the instance obj1 is assigned an rvalue. As expected from an rvalue, its destructor is called immediately afterwards. 
    But as we have made sure to null its data pointer in the move constructor, the actual data will not be deleted. 
    The advantage from a performance perspective in this case is that no deep-copy of the rvalue object needs to be made, 
    we are simply redirecting the internal resource handle thus making an efficient shallow copy.

    Next, another temporary instance with a size of 1200 bytes is created as a temporary object and "assigned" to obj3. 
    Note that while the call looks like an assignment, the move constructor is called under the hood, 
    making the call identical to MyMovableClass obj2(MyMovableClass(300));. By creating obj3 in such a way, 
    we are reusing the temporary rvalue and transferring ownership of its resources to the newly created obj3.

    Let us now consider a final example:
            void useObject(MyMovableClass obj)
        {
            std::cout << "using object " << &obj << std::endl;
        }

        int main()
        {
            MyMovableClass obj1(100); // constructor

            useObject(obj1);

            return 0;
        }
    In this case, an instance of MyMovableClass, obj1, is passed to a function useObject by value, thus making a copy of it.

    Let us take an immediate look at the output of the program, before going into details
    (1)
    CREATING instance of MyMovableClass at 0x7ffeefbff718 allocated with size = 400 bytes

    (2)
    COPYING content of instance 0x7ffeefbff718 to instance 0x7ffeefbff708

    using object 0x7ffeefbff708

    (3)
    DELETING instance of MyMovableClass at 0x7ffeefbff708

    (4)
    CREATING instance of MyMovableClass at 0x7ffeefbff6d8 allocated with size = 800 bytes

    (5)
    MOVING (c'tor) instance 0x7ffeefbff6d8 to instance 0x7ffeefbff6e8

    using object 0x7ffeefbff6e8

    DELETING instance of MyMovableClass at 0x7ffeefbff6e8
    DELETING instance of MyMovableClass at 0x7ffeefbff6d8
    DELETING instance of MyMovableClass at 0x7ffeefbff718

    First, we are creating an instance of MyMovableClass, obj1, by calling the constructor of the class (1).

    Then, we are passing obj1 by-value to a function useObject, which causes a temporary object obj to be instantiated, 
    which is a copy of obj1 (2) and is deleted immediately after the function scope is left (3).

    Then, the function is called with a temporary instance of MyMovableClass as its argument, 
    which creates a temporary instance of MyMovableClass as an rvalue (4). But instead of making a copy of it as before, 
    the move constructor is used (5) to transfer ownership of that temporary object to the function scope, 
    which saves us one expensive deep-copy.



    Moving lvalues
    There is one final aspect we need to look at: In some cases, it can make sense to treat lvalues like rvalues. 
    At some point in your code, you might want to transfer ownership of a resource to another part of your program as it is not needed anymore
    in the current scope. But instead of copying it, you want to just move it as we have seen before. 
    The "problem" with our implementation of MyMovableClass is that the call useObject(obj1) will trigger the copy constructor 
    as we have seen in one of the last examples. 
    But in order to move it, we would have to pretend to the compiler that obj1 was an rvalue instead of an lvalue 
    so that we can make an efficient move operation instead of an expensive copy.

    There is a solution to this problem in C++, which is std::move. 
    This function accepts an lvalue argument and returns it as an rvalue without triggering copy construction. 
    So by passing an object to std::move we can force the compiler to use move semantics, 
    either in the form of move constructor or the move assignment operator:
            int main()
        {
            MyMovableClass obj1(100); // constructor

            useObject(std::move(obj1));

            return 0;
        }
    Nothing much has changed, apart from obj1 being passed to the std::move function. The output would look like the following:
        CREATING instance of MyMovableClass at 0x7ffeefbff718 allocated with size = 400 bytes

        MOVING (c'tor) instance 0x7ffeefbff718 to instance 0x7ffeefbff708

        using object 0x7ffeefbff708

        DELETING instance of MyMovableClass at 0x7ffeefbff708
        DELETING instance of MyMovableClass at 0x7ffeefbff718
    By using std::move, we were able to pass the ownership of the resources within obj1 to the function useObject. 
    The local copy obj1 in the argument list was created with the move constructor and thus accepted the ownership transfer from obj1 to obj .
    Note that after the call to useObject, the instance obj1 has been invalidated 
    by setting its internal handle to null and thus may not be used anymore within the scope of main 
    (even though you could theoretically try to access it, but this would be a really bad idea).