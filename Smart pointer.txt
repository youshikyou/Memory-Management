6.1 Resource Acquisition is Initialization
Error-prone memory management with new and delete
In the previous chapters, we have seen that memory management on the heap using malloc/free or new/delete is extremely powerful, as they allow for a fine-grained control over the precious memory resource. However, the correct use of these concepts requires some degree of skill and experience (and concentration) from the programmer. If they are not handled correctly, bugs will quickly be introduced into the code. A major source of error is that the details around memory management with new/delete are completely left to the programer. In the remainder of this lesson, the pair malloc/free will be omitted for reasons of brevity. However, many of the aspects that hold for new/delete will also apply to malloc/free.

Let us take a look at some of the worst problems with new and delete:

Proper pairing of new and delete : Every dynamically allocated object that is created with new must be followed by a manual deallocation 
at a "proper" place in the program. If the programer forgets to call delete (which can happen very quickly) or if it is done 
at an "inappropriate" position, memory leaks will occur which might clog up a large portion of memory.

Correct operator pairing : C++ offers a variety of new/delete operators, especially when dealing with arrays on the heap. 
A dynamically allocated array initialized with new[] may only be deleted with the operator delete[]. If the wrong operator is used, 
program behavior will be undefined - which is to be avoided at all cost in C++.

Memory ownership : If a third-party function returns a pointer to a data structure, the only way of knowing who will be responsible 
for resource deallocation is by looking into either the code or the documentation. If both are not available (as is often the case), 
there is no way to infer the ownership from the return type. As an example, in the final project of this course, 
we will use the graphical library wxWidgets to create the user interface of a chatbot application. In wxWidgets, 
the programmer can create child windows and control elements on the heap using new, but the framework will take care of deletion altogether.
If for some reason the programmer does not know this, he or she might call delete and thus interfere with the inner workings of the wxWidgets
library.



The benefits of smart pointers
To put it briefly: Smart pointers were introduced in C++ to solve the above mentioned problems 
by providing a degree of automatic memory management: When a smart pointer is no longer needed (which is the case 
as soon as it goes out of scope), the memory to which it points is automatically deallocated. When contrasted with smart pointers, 
the conventional pointers we have seen so far are often termed "raw pointers".

In essence, smart pointers are classes that are wrapped around raw pointers. By overloading the -> and * operators, smart pointer objects 
make sure that the memory to which their internal raw pointer refers to is properly deallocated. 
This makes it possible to use smart pointers with the same syntax as raw pointers. As soon as a smart pointer goes out of scope, 
its destructor is called and the block of memory to which the internal raw pointer refers is properly deallocated. 
This technique of wrapping a management class around a resource has been conceived by Bjarne Stroustroup and is called 
Resource Acquisition Is Initialization (RAII). Before we continue with smart pointers and their usage let us take a close look at 
this powerful concept.



Resource Acquisition Is Initialization
The RAII is a widespread programming paradigm, that can be used to protect a resource such as a file stream, 
a network connection or a block of memory which need proper management.

Acquiring and releasing resources
In most programs of reasonable size, there will be many situations where a certain action at some point will necessitate a proper reaction 
at another point, such as:

1.Allocating memory with new or malloc, which must be matched with a call to delete or free.

2.Opening a file or network connection, which must be closed again after the content has been read or written.

3.Protecting synchronization primitives such as atomic operations, memory barriers, monitors or critical sections, 
which must be released to allow other threads to obtain them.

The 6.1.1 table gives a brief overview of some resources and their respective allocation and deallocation calls in C++.



The problem of reliable resource release
A general usage pattern common to the above examples looks like the following:
    obtain resources->use resources->release resources

However, there are several problems with this seemingly simple pattern:
    1.The program might throw an exception during resource use and thus the point of release might never be reached.
    2.There might be several points where the resource could potentially be released, making it hard for a programmer 
    to keep track of all eventualities.
    3.We might simply forget to release the resource again.




RAII to the rescue
The major idea of RAII revolves around object ownership and information hiding: 
Allocation and deallocation are hidden within the management class, so a programmer using the class does not 
have to worry about memory management responsibilities. If he has not directly allocated a resource, 
he will not need to directly deallocate it - 
whoever owns a resource deals with it. In the case of RAII this is the management class around the protected resource. 
The overall goal is to have allocation and deallocation (e.g. with new and delete) disappear from the surface level of the code you write.

RAII can be used to leverage - among others - the following advantages:

1.Use class destructors to perform resource clean-up tasks such as proper memory deallocation when the RAII object gets out of scope
2.Manage ownership and lifetime of dynamically allocated objects
3.Implement encapsulation and information hiding due to resource acquisition and release being performed within the same object.

In the following, let us look at RAII from the perspective of memory management. There are three major parts to an RAII class:

1.A resource is allocated in the constructor of the RAII class
2.The resource is deallocated in the destructor
3.All instances of the RAII class are allocated on the stack to reliably control the lifetime via the object scope


Let us now take a look at the code example6.1.1.cpp.

At the beginning of the program, an array of double values den is allocated on the stack. Within the loop, 
a new double is created on the heap using new. Then, the result of a division is printed to the console. 
At the end of the loop, delete is called to properly deallocate the heap memory to which en is pointing.
Even though this code is working as it is supposed to, it is very easy to forget to call delete at the end. 
Let us therefore use the principles of RAII to create a management class that calls delete automatically:

    class MyInt
    {
        int *_p; // pointer to heap data
    public:
        MyInt(int *p = NULL) { _p = p; }
        ~MyInt() 
        { 
            std::cout << "resource " << *_p << " deallocated" << std::endl;
            delete _p; 
        }
        int &operator*() { return *_p; } // // overload dereferencing operator
    };
In this example, the constructor of class MyInt takes a pointer to a memory resource. When the destructor of a MyInt object is called, 
the resource is deleted from memory - which makes MyInt an RAII memory management class. Also, the * operator is overloaded 
which enables us to dereference MyInt objects in the same manner as with raw pointers. 
Let us therefore slightly alter our code example from above to see how we can properly use this new construct:
    int main()
    {
        double den[] = {1.0, 2.0, 3.0, 4.0, 5.0};
        for (size_t I = 0; I < 5; ++i)
        {
            // allocate the resource on the stack
            MyInt en(new int(i));

            // use the resource
            std::cout << *en << "/" << den[i] << " = " << *en / den[i] << std::endl;
        }

        return 0;
    }

1.The part new int(i) creates a new block of memory on the heap and initializes it with the value of i. 
The returned result is the address of the block of memory.
2.The part MyInt en(…)calls the constructor of class MyInt, passing the address of a valid memory block as a parameter.

After creating an object of class MyInt on the stack, which, internally, created an integer on the heap, we can use the dereference 
operator in the same manner as before to retrieve the value to which the internal raw pointer is pointing. 
Because the MyInt object en lives on the stack, it is automatically deallocated after each loop cycle 
- which automatically calls the destructor to release the heap memory. The following console output verifies this:
    0/1 = 0
    resource 0 deallocated
    1/2 = 0.5
    resource 1 deallocated
    2/3 = 0.666667
    resource 2 deallocated
    3/4 = 0.75
    resource 3 deallocated
    4/5 = 0.8
    resource 4 deallocated
We have thus successfully used the RAII idiom to create a memory management class that spares us from thinking about calling delete. 
By creating the MyInt object on the stack, we ensure that the deallocation occurs as soon as the object goes out of scope.

6.3 Smart pointer
Smart pointer overview
Since C++11, the standard library includes smart pointers, which help to ensure that programs are free of memory leaks 
while also remaining exception-safe. With smart pointers, resource acquisition occurs at the same time that the object is initialized 
(when instantiated with make_shared or make_unique), so that all resources for the object are created and initialized in a single line of code.

In modern C++, raw pointers managed with new and delete should only be used in small blocks of code with limited scope, 
where performance is critical (such as with placement new) and ownership rights of the memory resource are clear. 
We will look at some guidelines on where to use which pointer later.

C++11 has introduced three types of smart pointers, which are defined in the header of the standard library:

1.The unique pointer std::unique_ptr is a smart pointer which exclusively owns a dynamically allocated resource on the heap. 
There must not be a second unique pointer to the same resource.

2.The shared pointer std::shared_ptr points to a heap resource but does not explicitly own it. 
There may even be several shared pointers to the same resource, each of which will increase an internal reference count. 
As soon as this count reaches zero, the resource will automatically be deallocated.

3.The weak pointer std::weak_ptr behaves similar to the shared pointer but does not increase the reference counter.

Prior to C++11, there was a concept called std::auto_ptr, which tried to realize a similar idea. 
However, this concept can now be safely considered as deprecated and should not be used anymore.



The Unique pointer
A unique pointer is the exclusive owner of the memory resource it represents. 
There must not be a second unique pointer to the same memory resource, otherwise there will be a compiler error. 
As soon as the unique pointer goes out of scope, the memory resource is deallocated again. 
Unique pointers are useful when working with a temporary heap resource that is no longer needed once it goes out of scope.

The 6.3.1 diagram illustrates the basic idea of a unique pointer:
In the example, a resource in memory is referenced by a unique pointer instance sourcePtr. 
Then, the resource is reassigned to another unique pointer instance destPtr using std::move. 
The resource is now owned by destPtr while sourcePtr can still be used but does not manage a resource anymore.

See example6.3.1uniquepointer.cpp
A unique pointer is constructed using the following syntax:
The function RawPointer contains the familiar steps of 
(1) allocating memory on the heap with new and storing the address in a pointer variable, 
(2) assigning a value to the memory block using the dereferencing operator * and 
(3) finally deleting the resource on the heap. As we already know, forgetting to call delete will result in a memory leak.

The function UniquePointer shows how to achieve the same goal using a smart pointer from the standard library. 
As can be seen, a smart pointer is a class template that is declared on the stack and then initialized by a raw pointer (returned by new ) 
to a heap-allocated object. The smart pointer is now responsible for deleting the memory that the raw pointer specifies 
- which happens as soon as the smart pointer goes out of scope. Note that smart pointers always need to be declared on the stack, 
otherwise the scoping mechanism would not work.

The smart pointer destructor contains the call to delete, and because the smart pointer is declared on the stack, 
its destructor is invoked when the smart pointer.

In the exampl6.3.1uniquepointer2.cpp, we will construct a unique pointer to a custom class. Also, we will see how the standard -> and * operators 
can be used to access member functions of the managed object, just as we would with a raw pointer:

Note that the custom class MyClass has two constructors, one without arguments and one with a string to be passed, 
which initializes a member variable _text that lives on the stack. Also, once an object of this class gets destroyed, 
a message to the console is printed, along with the value of _text. 
In main, two unique pointers are created with the address of a MyClass object on the heap as arguments. 
With myClass2, we can see that constructor arguments can be passed just as we would with raw pointers. After both pointers have been created,
we can use the -> operator to access members of the class, such as calling the function setText. 
From looking at the function call alone you would not be able to tell that myClass1 is in fact a smart pointer. 
Also, we can use the dereference operator * to access the value of myClass1 and myClass2 and assign the one to the other. 
Finally, the . operator gives us access to proprietary functions of the smart pointer

The console output of the program looks like the following:
    Objects have stack addresses 0x1004000e0 and 0x100400100
    String 2 destroyed
    String 2 destroyed

Obviously, both pointers have different addresses on the stack, even after copying the contents from myClass2 to myClass1. 
As can be seen from the last two lines of the output, the destructor of both objects gets called automatically at the end of the program and 
- as expected - the value of the internal string is identical due to the copy.

Summing up, the unique pointer allows a single owner of the underlying internal raw pointer. 
Unique pointers should be the default choice unless you know for certain that sharing is required at a later stage. 
We have already seen how to transfer ownership of a resource using the Rule of Five and move semantics. 
Internally, the unique pointer uses this very concept along with RAII to encapsulate a resource (the raw pointer) 
and transfer it between pointer objects when either the move assignment operator or the move constructor are called. 
Also, a key feature of a unique pointer, which makes it so well-suited as a return type for many functions, 
is the possibility to convert it to a shared pointer.



The Shared Pointer
Just as the unique pointer, a shared pointer owns the resource it points to. 
The main difference between the two smart pointers is that shared pointers keep a reference counter on how many of them point 
to the same memory resource. Each time a shared pointer goes out of scope, the counter is decreased. When it reaches zero 
(i.e. when the last shared pointer to the resource is about to vanish). the memory is properly deallocated. 
This smart pointer type is useful for cases where you require access to a memory location on the heap in multiple parts of your program 
and you want to make sure that whoever owns a shared pointer to the memory can rely on the fact that it will be accessible 
throughout the lifetime of that pointer.

The 6.2.2 diagram illustrates the basic idea of a shared pointer.

We can see that shared pointers are constructed just as unique pointers are. 
Also, we can access the internal reference count by using the method use_count(). 
In the inner block, a second shared pointer shared2 is created and shared1 is assigned to it. 
In the copy constructor, the internal resource pointer is copied to shared2 and the resource counter is incremented in 
both shared1 and shared2. Let us take a look at the output of the code:
    shared pointer count = 1
    shared pointer count = 2
    shared pointer count = 1

You may have noticed that the lifetime of shared2 is limited to the scope denoted by the enclosing curly brackets. 
Thus, once this scope is left and shared2 is destroyed, the reference counter in shared1 is decremented by one.

A shared pointer can also be redirected by using the reset() function. 
If the resource which a shared pointer manages is no longer needed in the current scope, the pointer 
can be reset to manage a difference resource as illustrated in the example6.3.2sharepointer2.cpp

Note that in the example, the destructor of MyClass prints a string to the console when called. 
The output of the program looks like the following:
    shared pointer count = 1
    Destructor of MyClass called
    shared pointer count = 1
    Destructor of MyClass called
After creation, the program prints 1 as the reference count of shared. 
Then, the reset function is called with a new instance of MyClass as an argument. 
This causes the destructor of the first MyClass instance to be called, hence the console output. 
As can be seen, the reference count of the shared pointer is still at 1. Then, at the end of the program,
the destructorof the second MyClass object is called.

Despite all the advantages of shared pointers, it is still possible to have problems with memory management though. 
Consider the scenario example6.3.2sharepointer3.cpp

In main, two shared pointers myClass1 and myClass2 which are managing objects of type MyClass are allocated on the stack. 
As can be seen from the console output, both smart pointers are automatically deallocated when the scope of main ends:
    Destructor of MyClass called
    Destructor of MyClass called
When the following two lines are added to main, the result is quite different:
    myClass1->_member = myClass2;
    myClass2->_member = myClass1;
These two lines produce a circular reference. When myClass1 goes out of scope at the end of main, 
its destructor can’t clean up memory as there is still a reference count of 1 in the smart pointer, which is caused by 
the shared pointer _member in myClass2. The same holds true for myClass2, which can not be properly deleted as there is still a shared pointer
to it in myClass1. This deadlock situation prevents the destructors from being called and causes a memory leak. 
When we use Valgrind on this program, we get the following summary:

    ==20360== LEAK SUMMARY:
    ==20360==    definitely lost: 16 bytes in 1 blocks
    ==20360==    indirectly lost: 80 bytes in 3 blocks
    ==20360==      possibly lost: 72 bytes in 3 blocks
    ==20360==    still reachable: 200 bytes in 6 blocks
    ==20360==         suppressed: 18,985 bytes in 160 blocks
As can be seen, the memory leak is clearly visible with 16 bytes being marked as "definitely lost". 
To prevent such circular references, there is a third smart pointer.



The Weak Pointer
Similar to shared pointers, there can be multiple weak pointers to the same resource. 
The main difference though is that weak pointers do not increase the reference count. Weak pointers hold a non-owning reference 
to an object that is managed by another shared pointer.

The following rule applies to weak pointers: You can only create weak pointers out of shared pointers or out of another weak pointer. 
The code on the right shows a few examples of how to use and how not to use weak pointers.

The output looks as follows:
    shared pointer count = 1
    shared pointer count = 1

First, a shared pointer to an integer is created with a reference count of 1 after creation. 
Then, two weak pointers to the integer resource are created, the first directly from the shared pointer 
and the second indirectly from the first weak pointer. As can be seen from the output, neither of both weak pointers increased 
the reference count. 

As we have seen with raw pointers, you can never be sure wether the memory resource to which the pointer refers is still valid. 
With a weak pointer, even though this type does not prevent an object from being deleted, the validity of its resource can be checked. 
The example6.3.3weakpointer2.cpp illustrates how to use the expired() function to do this.

Thus, with smart pointers, there will always be a managing instance which is responsible for the proper allocation and deallocation 
of a resource. In some cases it might be necessary to convert from one smart pointer type to another.

Converting between smart pointers
The example on the right illustrates how to convert between the different pointer types.

In (1), a conversion from unique pointer to shared pointer is performed. You can see that this can be achieved by using std::move, 
which calls the move assignment operator on sharedPtr1 and steals the resource from uniquePtr 
while at the same time invalidating its resource handle on the heap-allocated integer.

In (2), you can see how to convert from weak to shared pointer. Imagine that you have been passed a weak pointer to a memory object 
which you want to work on. To avoid invalid memory access, you want to make sure that the object will not be deallocated 
before your work on it has been finished. To do this, you can convert a weak pointer to a shared pointer by calling the lock() function 
on the weak pointer.

In (3), a raw pointer is extracted from a shared pointer. However, this operation does not decrease the reference count within sharedPtr2. 
This means that calling delete on rawPtr in the last line before main returns will generate a runtime error as a resource is 
trying to be deleted which is managed by sharedPtr2 and has already been removed. The output of the program when compiled with g++ thus is:
    malloc: *** error for object 0x1003001f0: pointer being freed was not allocated

Note that there are no options for converting away from a shared pointer. Once you have created a shared pointer, 
you must stick to it (or a copy of it) 



When to use raw pointers and smart pointers?
As a general rule of thumb with modern C++, smart pointers should be used often. 
They will make your code safer as you no longer need to think (much) about the proper allocation and deallocation of memory. 
As a consequence, there will be much fewer memory leaks caused by dangling pointers or crashes from accessing invalidated memory blocks.

When using raw pointers on the other hand, your code might be susceptible to the following bugs:
    1.Memory leaks
    2.Freeing memory that shouldn’t be freed
    3.Freeing memory incorrectly
    4.Using memory that has not yet been allocated
    5.Thinking that memory is still allocated after being freed
With all the advantages of smart pointers in modern C++, one could easily assume that it would be best to completely ban the use of new 
and delete from your code. However, while this is in many cases possible, it is not always advisable as well. 
Let us take a look at the C++ core guidelines, which has several rules for explicit memory allocation and deallocation. 
In the scope of this course, we will briefly discuss three of them:

R. 10: Avoid malloc and free While the calls (MyClass*)malloc( sizeof(MyClass) ) and new MyClass both allocate a block of memory on the heap 
in a perfectly valid manner, only new will also call the constructor of the class and free the destructor. 
To reduce the risk of undefined behavior, malloc and free should thus be avoided.

R. 11: Avoid calling new and delete explicitly Programmers have to make sure that every call of new is paired with the appropriate delete 
at the correct position so that no memory leak or invalid memory access occur. The emphasis here lies in the word "explicitly" 
as opposed to implicitly, such as with smart pointers or containers in the standard template library.

R. 12: Immediately give the result of an explicit resource allocation to a manager object It is recommended to make use of manager objects 
for controlling resources such as files, memory or network connections to mitigate the risk of memory leaks. 
This is the core idea of smart pointers as discussed at length in this section.

Summarizing, raw pointers created with new and delete allow for a high degree of flexibility and control over the managed memory 
as we have seen in earlier lessons of this course. To mitigate their proneness to errors, 
the following additional recommendations can be given:

    1.A call to new should not be located too far away from the corresponding delete. 
    It is bad style to stretch you new / delete pairs throughout your program with references criss-crossing your entire code.

    2.Calls to new and delete should always be hidden from third parties.

In addition to the above recommendations, the C++ core guidelines also contain a total of 13 rules for the recommended use of smart pointers. 
In the following, we will discuss a selection of these:

    R. 20 : Use unique_ptr or shared_ptr to represent ownership
    R. 21 : Prefer unique_ptr over std::shared_ptr unless you need to share ownership

Both pointer types express ownership and responsibilities (R. 20). A unique_ptr is an exclusive owner of the managed resource; 
therefore, it cannot be copied, only moved. In contrast, a shared_ptr shares the managed resource with others. 
As described above, this mechanism works by incrementing and decrementing a common reference counter. 
The resulting administration overhead makes shared_ptr more expensive than unique_ptr. 
For this reason unique_ptr should always be the first choice (R. 21).

    R. 22 : Use make_shared() to make shared_ptr
    R. 23 : Use make_unique() to make std::unique_ptr

The increased management overhead compared to raw pointers becomes in particular true if a shared_ptr is used. 
Creating a shared_ptr requires (1) the allocation of the resource using new and (2) the allocation and management of the reference counter. 
Using the factory function make_shared is a one-step operation with lower overhead and should thus always be preferred. (R.22). 
This also holds for unique_ptr (R.23), although the performance gain in this case is minimal (if existent at all).

But there is an additional reason for using the make_... factory functions: Creating a smart pointer in a single step removes 
the risk of a memory leak. Imagine a scenario where an exception happens in the constructor of the resource. In such a case, 
the object would not be handled properly and its destructor would never be called - even if the managing object goes out of scope. 
Therefore, make_shared and make_unique should always be preferred. Note that make_unique is only available with compilers 
that support at least the C++14 standard.

    R. 24 : Use weak_ptr to break cycles of shared_ptr
We have seen that weak pointers provide a way to break a deadlock caused by two owning references which are cyclicly referring to each other.
With weak pointers, a resource can be safely deallocated as the reference counter is not increased.



6.5 Transfer ownership
Passing smart pointers to functions
Let us consider the following recommendation of the C++ guidelines on smart pointers:

    R. 30 : Take smart pointers as parameters only to explicitly express lifetime semantics

The core idea behind this rule is the notion that functions that only manipulate objects 
without affecting its lifetime in any way should not be concerned with a particular kind of smart pointer. 
A function that does not manipulate the lifetime or ownership should use raw pointers or references instead. 
A function should take smart pointers as parameter only if it examines or manipulates the smart pointer itself. 
As we have seen, smart pointers are classes that provide several features such as counting the references of a shared_ptr 
or increasing them by making a copy. Also, data can be moved from one unique_ptr to another and thus transferring the ownership. 
A particular function should accept smart pointers only if it expects to do something of this sort. 
If a function just needs to operate on the underlying object without the need of using any smart pointer property, 
it should accept the objects via raw pointers or references instead.

The following examples are pass-by-value types that lend the ownership of the underlying object:

    void f(std::unique_ptr<MyObject> ptr)
    void f(std::shared_ptr<MyObject> ptr)
    void f(std::weak_ptr<MyObject> ptr)

Passing smart pointers by value means to lend their ownership to a particular function f. 
In the above examples 1-3, all pointers are passed by value, i.e. the function f has a private copy of it which it can (and should) modify. 
Depending on the type of smart pointer, a tailored strategy needs to be used.

R.32: Take a unique_ptr parameter to express that a function assumes ownership of a widget

The basic idea of a unique_ptr is that there exists only a single instance of it. 
This is why it can’t be copied to a local function but needs to be moved instead with the function std::move. 
The code example6.5.1.cpp on the right illustrates the principle of transferring the object managed by the unique pointer uniquePtr into a function f.

The class MyClass has a private object _member and a public function printVal() which prints the address of the managed object (this) 
as well as the member value to the console. In main, an instance of MyClass is created by the factory function make_unique() 
and assigned to a unique pointer instance uniquePtr for management. 
Then, the pointer instance is moved into the function f using move semantics. 
As we have not overloaded the move constructor or move assignment operator in MyClass, the compiler is using the default implementation. 
In f, the address of the copied / moved unique pointer ptr is printed and the function printVal() is called on it. 
When the path of execution returns to main(), the program checks for the validity of uniquePtr and, if valid, 
calls the function printVal() on it again. Here is the console output of the program:

    unique_ptr 0x7ffeefbff710, managed object 0x100300060 with val = 23
    unique_ptr 0x7ffeefbff6f0, managed object 0x100300060 with val = 23

The output nicely illustrates the copy / move operation. 
Note that the address of unique_ptr differs between the two calls while the address of the managed object as well as of the value are identical.
This is consistent with the inner workings of the move constructor, which we overloaded in a previous section. 
The copy-by-value behavior of f() creates a new instance of the unique pointer but then switches the address of the managed MyClass instance 
from source to destination. After the move is complete, we can still use the variable uniquePtr in main but it now is only an empty shell.



When passing a shared pointer by value, move semantics are not needed. 
As with unique pointers, there is an underlying rule for transferring the ownership of a shared pointer to a function:

    R.34: Take a shared_ptr parameter to express that a function is part owner
Consider the example6.5.2.cpp. The main difference in this example is that the MyClass instance is managed by a shared pointer. 
After creation in main(), the address of the pointer object as well as the current reference count are printed to the console.
Then, sharedPtr is passed to the function f() by value, i.e. a copy is made. After returning to main, 
pointer address and reference counter are printed again. Here is what the output of the program looks like:
    shared_ptr (ref_cnt= 1) 0x7ffeefbff708, managed object 0x100300208 with val = 23
    shared_ptr (ref_cnt= 2) 0x7ffeefbff6e0, managed object 0x100300208 with val = 23
    shared_ptr (ref_cnt= 1) 0x7ffeefbff708, managed object 0x100300208 with val = 23


Throughout the program, the address of the managed object does not change. When passed to f() , the reference count changes to 2. 
After the function returns and the local shared_ptr is destroyed, the reference count changes back to 1. In summary, 
move semantics are usually not needed when using shared pointers. Shared pointers can be passed by value safely 
and the main thing to remember is that with each pass, the internal reference counter is increased while the managed object stays the same.

Without giving an example here, the weak_ptr can be passed by value as well, just like the shared pointer. 

With the above examples, pass-by-value has been used to lend the ownership of smart pointers. 
Now let us consider the following additional rules from the C++ guidelines on smart pointers:

    R.33: Take a unique_ptr& parameter to express that a function reseats the widget

    R.35: Take a shared_ptr& parameter to express that a function might reseat the shared pointer

Both rules recommend passing-by-reference, when the function is supposed to modify the ownership of an existing smart pointer and not a copy.
We pass a non-const reference to a unique_ptr to a function if it might modify it in any way, including deletion 
and reassignment to a different resource.

Passing a unique_ptr as const is not useful as the function will not be able to do anything with it: Unique pointers are all about proprietary
ownership and as soon as the pointer is passed, the function will assume ownership. 
But without the right to modify the pointer, the options are very limited.

A shared_ptr can either be passed as const or non-const reference. 
The const should be used when you want to express that the function will only read from the pointer or it might create a local copy 
and share ownership.

Lastly, we will take a look at passing raw pointers and references. 
The general rule of thumb is that we can use a simple raw pointer (which can be null) or a plain reference (which can not be null),
when the function we are passing will only inspect the managed object without modifying the smart pointer. 
The internal (raw) pointer to the object can be retrieved using the get() member function. Also, by providing access to the raw pointer, 
you can use the smart pointer to manage memory in your own code and pass the raw pointer to code that does not support smart pointers.

When using raw pointers retrieved from the get() function, you should take special care not to delete them or to create new smart pointers 
from them. If you did so, the ownership rules applying to the resource would be severely violated. When passing a raw pointer to a function 
or when returning it (see next section), raw pointers should always be considered as owned by the smart pointer.



Returning smart pointers from functions
With return values, the same logic that we have used for passing smart pointers to functions applies: 
Return a smart pointer, both unique or shared, if the caller needs to manipulate or access the pointer properties. 
In case the caller just needs the underlying object, a raw pointer should be returned.

Smart pointers should always be returned by value. This is not only simpler but also has the following advantages:

1.The overhead usually associated with return-by-value due to the expensive copying process is significantly mitigated 
by the built-in move semantics of smart pointers. They only hold a reference to the managed object, 
which is quickly switched from destination to source during the move process.

2.Since C++17, the compiler used Return Value Optimization (RVO) to avoid the copy usually associated with return-by-value. 
This technique, together with copy-elision, is able to optimize even move semantics and smart pointers 
(not in call cases though, they are still an essential part of modern C++).

3.When returning a shared_ptr by value, the internal reference counter is guaranteed to be properly incremented. 
This is not the case when returning by pointer or by reference.



Best-Practices for Passing Smart Pointers
This sections contains a condensed summary of when (and when not) to use smart pointers and how to properly pass them between functions. 
This section is intended as a guide for your future use of this important feature in modern C++ and will hopefully encourage 
you not to ditch raw pointers altogether but instead to think about where your code could benefit from smart pointers 
- and when it would most probably not.

The following list contains all the variations (omitting const) of passing an object to a function:
    void f( object* );  // (a)
    void f( object& ); // (b)
    void f( unique_ptr<object> ); // (c)
    void f( unique_ptr<object>& ); // (d)
    void f( shared_ptr<object> ); // (e)
    void f( shared_ptr<object>& ); // (f)

The Preferred Way
The preferred way of to pass object parameters is by using a) or b) .
In doing so, we do not have to worry about the lifetime policy a caller might have implemented. 
Using a specific smart pointer in a case where we only want to observe an object or manipulate a member might be overly restrictive.

With the non-owning raw pointer * or the reference & we can observe an object from which we can assume that its lifetime 
will exceed the lifetime of the function parameter. In concurrency however, this might not be the case, but for linear code 
we can safely assume this.

To decide wether a * or & is more appropriate, you should think about wether you need to express that there is no object. 
This can only be done with pointers by passing e.g. nullptr. In most other cases, you should use a reference instead.



The Object Sink
The preferred way of passing an object to a function so that the function takes ownership of the object (or „consumes“ it) \
is by using method c) from the above list:

    void f( unique_ptr<object> );

In this case, we are passing a unique pointer by value from caller to function, 
which then takes ownership of the the pointer and the underlying object. 
This is only possible using move semantics as there may be only a single reference to the object managed by the unique pointer.

After the object has been passed in this way, the caller will have an invalid unique pointer and the function to which the object 
now belongs may destroy it or move it somewhere else.

Using const with this particular call does not make sense as it models an ownership transfer so the source will be definitely modified.



In And Out Again 1
In some cases, we want to modify a unique pointer (not necessarily the underlying object) and re-use it in the context of the caller. 
In this case, method d) from the above list might be most suitable:

    void f( unique_ptr<object>& );

Using this call structure, the function states that it might modify the smart pointer, e.g. by redirecting it to another object. 
It is not recommended to use it for accepting an object only because we should avoid restricting ourselves unnecessarily to a particular object
lifetime strategy on the caller side.

Using const with this call structure is not recommendable as we would not be able to modify the unique_ptr in this case. 
In case you want to modify the underlying object, use method a) instead.



Sharing Object Ownership
In the last examples, we have looked at strategies involving unique ownership. 
In this example, we want to express that a function will store and share ownership of an object on the heap. 
This can be achieved by using method e) from the list above:

    void f( shared_ptr<object> )

In this example, we are making a copy of the shared pointer passed to the function. 
In doing so, the internal reference counter within all shared pointers referring to the same heap object is incremented by one.

This strategy can be recommended for cases where the function needs to retain a copy of the shared_ptr and thus share ownership of the object.
This is of interest when we need access to smart pointer functions such as the reference count 
or we must make sure that the object to which the shared pointer refers is not prematurely deallocated 
(which might happen in concurrent programming).

If the local scope of the function is not the final destination, a shared pointer can also be moved, 
which does not increase the reference count and is thus more effective.

A disadvantage of using a shared_ptr as a function argument is that the function will be limited to using only objects 
that are managed by shared pointers - which limits flexibility and reusability of the code.



In And Out Again 2
As with unique pointers, the need to modify shared pointers and re-use them in the context of the caller might arise. 
In this case, method f) might be the right choice:

    void f( shared_ptr<object>& );

This particular way of passing a shared pointer expresses that the function f will modify the pointer itself. 
As with method e), we will be limiting the usability of the function to cases where the object is managed by a shared_ptr and nothing else.




