3.1 The process memory model
    As we have seen in the previous lesson, each program is assigned its own virtual memory by the operating system. 
    This address space is arranged in a linear fashion with one block of data being stored at each address. 
    It is also divided into several distinct areas as illustrated by 3.1.1 figure

    The last address 0cFFFFFFFF converts to the decimal 4.294.967.295 , which is the total amount of memory blocks 
    that can theoretically addressed in a 32 bit operating system - hence the well-known limit of 4GB of memory. 
    On a 64 bit system, the available space is significantly (!) larger. Also, the addresses are stored with 8 bytes instead of 4 bytes.

    From a programming perspective though, we are not able to use the entire address space. 
    Instead, the blocks "OS Kernel Space" and "Text" are reserved for the operating system. In kernel space, 
    only the most trusted code is executed - it is fully maintained by the operating system and serves as an interface 
    between the user code and the system kernel. In this course, we will not be directly concerned with this part of memory. 
    The section called 'text' holds the program code generated by the compiler and linker. As with the kernel space, 
    we will not be using this block directly in this course. Let us now take a look at the remaining blocks, starting from the top:

    1.The stack is a contiguous memory block with a fixed maximum size. If a program exceeds this size, it will crash. 
    The stack is used for storing automatically allocated variables such as local variables or function parameters. 
    If there are multiple threads in a program, then each thread has its own stack memory. 
    New memory on the stack is allocated when the path of execution enters a scope and freed again once the scope is left. 
    It is important to know that the stack is managed "automatically" by the compiler, 
    which means we do not have to concern ourselves with allocation and deallocation.

    2.The heap (also called "free store" in C++) is where data with dynamic storage lives. It is shared among multiple threads in a program, 
    which means that memory management for the heap needs to take concurrency into account. 
    This makes memory allocations in the heap more complicated than stack allocations. 
    In general, managing memory on the heap is more (computationally) expensive for the operating system, 
    which makes it slower than stack memory. Contrary to the stack, the heap is not managed automatically by the system, 
    but by the programmer. If memory is allocated on the heap, it is the programmer’s responsibility to free it again
    when it is no longer needed. If the programmer manages the heap poorly or not at all, there will be trouble.

    3.The BSS (Block Started by Symbol) segment is used in many compilers and linkers for a segment that contains global and static variables 
    that are initialized with zero values. This memory area is suitable, for example, for arrays that are not initialized 
    with predefined values.

    4.The Data segment serves the same purpose as the BSS segment with the major difference being that variables 
    in the Data segment have been initialized with a value other than zero. Memory for variables in the Data segment (and in BSS) 
    is allocated once when a program is run and persists throughout its lifetime. 



    Memory Allocation in C++
    Now that we have an understanding of the available process memory, let us take a look at memory allocation in C++.

    Not every variable in a program has a permanently assigned area of memory. 
    The term allocate refers to the process of assigning an area of memory to a variable to store its value. 
    A variable is deallocated when the system reclaims the memory from the variable, so it no longer has an area to store its value.

    Generally, three basic types of memory allocation are supported:

    Static memory allocation is performed for static and global variables, which are stored in the BSS and Data segment. 
    Memory for these types of variables is allocated once when your program is run and persists throughout the life of your program.

    Automatic memory allocation is performed for function parameters as well as local variables, which are stored on the stack. 
    Memory for these types of variables is allocated when the path of execution enters a scope and freed again once the scope is left.

    Dynamic memory allocation is a possibility for programs to request memory from the operating system at runtime when needed. 
    This is the major difference to automatic and static allocation, where the size of the variable must be known at compile time. 
    Dynamic memory allocation is not performed on the limited stack but on the heap and is thus (almost) only limited 
    by the size of the address space.

3.2 Automatic Memory Allocation (The Stack)
    Properties of Stack Memory
    In the available literature on C++, the terms stack and heap are used regularly, even though this is not formally correct: 
    C++ has the free space, storage classes and the storage duration of objects. 
    However, since stack and heap are widely used in the C++ community, we will also use it throughout this course. 
    Should you come across the above-mentioned terms in a book or tutorial on the subject, 
    you now know that they refer to the same concepts as stack and heap do.

    As mentioned in the last section, the stack is the place in virtual memory where the local variables reside, 
    including arguments to functions. Each time a function is called, the stack grows (from top to bottom) and each time a function returns, 
    the stack contracts. When using multiple threads (as in concurrent programming), it is important to know that each thread has its own stack memory - which can be considered thread-safe.

    In the following, a short list of key properties of the stack is listed:

    1.The stack is a contiguous block of memory. It will not become fragmented (as opposed to the heap) and it has a fixed maximum size.

    2.When the maximum size of the stack memory is exceeded, a program will crash.

    3.Allocating and deallocating memory is fast on the stack. It only involves moving the stack pointer to a new position.

    The 3.2.1 diagram shows the stack memory during a function call:
    The variable x is created on the stack within the scope of main. 
    Then, a stack frame which represents the function Add and its variables is pushed to the stack, moving the stack pointer further downwards.
    It can be seen that this includes the local variables a and b, as well as the return address, a base pointer and finally the return value s.

    In the example3.1.1.cpp, we will look at the behavior of the stack when local variables are allocated and a function is called. 

    Within the main function, we see two declarations of local variables i and j followed by a call to MyFunc, 
    where another local variable is allocated. After MyFunc returns, another local variable is allocated in main. 
    The program generates the following output:
    1: 0x7ffeefbff688 
    2: 0x7ffeefbff684 
    3: 0x7ffeefbff65c 
    4: 0x7ffeefbff680 
    Between 1 and 2, the stack address is reduced by 4 bytes, which corresponds to the allocation of memory for the int j.

    Between 2 and 3, the address pointer is moved by 0x28. We can easily see that calling a function causes 
    a significant amount of memory to be allocated. In addition to the local variable of MyFunc, the compiler needs to store additional data 
    such as the return address.

    Between 3 and 4, MyFunc has returned and a third local variable k has been allocated on the stack. 
    The stack pointer now has moved back to a location which is 4 bytes relative to position 2.
    This means that after returning from MyFunc, the stack has contracted to the size it had before the function call.

    The 3.2.2 diagram illustrates how the stack grows and contracts during program execution.



    Total Stack Size
    When a thread is created, stack memory is allocated by the operating system as a contiguous block. 
    With each new function call or local variable allocation, the stack pointer is moved until eventually it 
    will reach the bottom of said memory block. Once it exceeds this limit (which is called "stack overflow"), 
    the program will crash. We will try to find out the limit of your computer’s stack memory in the example3.2.2.cpp

3.3 Call-By-Value vs. Call-By-Reference
    Variable Scopes in C++
    The time between allocation and deallocation is called the lifetime of a variable. 
    Using a variable after its lifetime has ended is a common programming error, against which most modern languages try to protect: 
    Local variables are only available within their respective scope (e.g. inside a function) and are simply not available outside - 
    so using them inappropriately will result in a compile-time error. 
    When using pointer variables however, programmers must make sure that allocation is handled correctly 
    and that no invalid memory addresses are accessed.

    The example3.3.1.CPP shows a set of local (or automatic) variables, whose lifetime is bound to the function they are in.

    When MyLocalFunction is called, the local variable isBelowThreshold is allocated on the stack. 
    When the function exits, it is again deallocated.

    For the allocation of local variables, the following holds:

    1.Memory is allocated for local variables only after a function has been called. 
    The parameters of a function are also local variables and they are initialized with a value copied from the caller.

    2.As long as the current thread of execution is within function A, memory for the local variables remains allocated. 
    This even holds true in case another function B is called from within the current function A 
    and the thread of execution moves into this nested function call. 
    However, within function B, the local variables of function A are not known.

    3.When the function exits, its locals are deallocated and there is now way to them afterwards 
    - even if the address were still known (e.g. by storing it within a pointer).



    Passing Variables by Value
    When calling a function as in the previous code example, its parameters (in this case myInt) 
    are used to create local copies of the information provided by the caller. 
    The caller is not sharing the parameter with the function but instead a proprietary copy is created 
    using the assignment operator = (more about that later). When passing parameters in such a way, 
    it is ensured that changes made to the local copy will not affect the original on the caller side. 
    The upside to this is that inner workings of the function and the data owned by the caller are kept neatly separate.

    However, there are two major downsides to this:

    1.Passing parameters by value means that a copy is created, which is an expensive operation that might consume large amounts of memory, 
    depending on the data that is being transferred. Later in this course we will encounter "move semantics", 
    which is an effective way to compensate for this downside.
    2.Passing by value also means that the created copy can not be used as a back channel for communicating with the caller, 
    for example by directly writing the desired information into the variable.
    Consider the example3.3.2.cpp. In main, the integer val is initialized with 0. 
    When passing it to the function AddTwo, a local copy of val is created, which only exists within the scope of AddTwo, 
    so the add-operation has no effect on val on the caller side. So when main returns, val has a value of 2 instead of 4.

    However, with a slight modification, we can easily create a backchannel to the caller side. Consider example3.3.cpp.

    In this case, when passing the parameter to the function AddThree, we are creating a local copy as well 
    but note that we are now passing a pointer variable. This means that a copy of the memory address of val is created, 
    which we can then use to directly modify its content by using the dereference operator *.



    Passing Variables by Reference
    The second major way of passing parameters to a function is by reference. 
    With this way, the function receives a reference to the parameter, rather than a copy of its value. 
    As with the example of AddThree above, the function can now modify the argument such that the changes also happen on the caller side. 
    In addition to the possibility to directly exchange information between function and caller, 
    passing variables by reference is also faster as no information needs to be copied, as well as more memory-efficient.

    A major disadvantage is that the caller does not always know what will happen to the data it passes to a function 
    (especially when the function code can not be modified easily). 
    Thus, in some cases, special steps must be taken to protect ones data from inappropriate modification.
    Look at example3.3.4.cpp.
    To pass a variable by reference, we simply declare the function parameters as references using & rather than as normal variables. 
    When the function is called, val will become a reference to the argument. 
    Since a reference to a variable is treated exactly the same as the variable itself, 
    any changes made to the reference are passed through to the argument!



    Pointers vs. References
    As we have seen in the examples above, the use of pointers and references to directly manipulate function arguments in a memory-effective 
    way is very similar. Let us compare the two methods in example3.3.5.cpp.

    As can be seen, pointer and reference are both implemented by using a memory address. 
    In the case of AddFour the caller does not even realize that val might be modified 
    while with AddSix, the reference to val has to be explicitly written by using &.

    If passing by value needs to be avoided, both pointers and references are a way to achieve this. 
    The following selection of properties contrasts the two methods 
    so it will be easier to decide which to use from the perspective of the use-case at hand:

    1.Pointers can be declared without initialization. This means we can pass an uninitialized pointer to a function 
    who then internally performs the initialization for us.

    2.Pointers can be reassigned to another memory block on the heap.

    3.References are usually easier to use (depending on the expertise level of the programmer). 
    Sometimes however, if a third-party function is used without properly looking at the parameter definition, 
    it might go unnoticed that a value has been modified.


    Stack usage
    Now, we will compare the three strategies we have seen so far with regard to stack memory usage. Consider example3.3.6stackusage.cpp.

    After creating a local variable i in main to give us the address of the stack bottom, we are passing i by-value to our first function. 
    Inside CallByValue, the memory address of a local variable j is printed to the console, which serves as a marker for the stack pointer. 
    With the second function call in main, we are passing a reference to i to CallByPointer.
    Lastly, the function CallByReference is called in main, which again takes the integer i as an argument. 
    However, from looking at main alone, we can not tell wether i will be passed by value or by reference.

    Let us take a look at the respective differences to the stack bottom in turn:

    CallByValue requires 32 bytes of memory. As discussed before,
    this is reserved for e.g. the function return address and for the local variables within the function (including the copy of i).

    CallByPointer on the other hand requires - perhaps surprisingly - 36 bytes of memory. 
    Let us complete the examination before going into more details on this result.

    CallByReference finally has the same memory requirements as CallByPointer.

    Why does CallByValue require more memory?
    The size of the pointer variable is larger than the actual data type. As a 64 bit architecture, an address requires 8 byte.
    In order to benefit from call-by-reference, the size of the data type passed to the function has to surpass the size of the pointer 
    on the respective architecture (i.e. 32 bit or 64 bit).

